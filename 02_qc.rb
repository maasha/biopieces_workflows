#!/usr/bin/env ruby

# Collect some QC stats for all reads in all samples. For each sample score
# plots and residue distribution plots are generated by merging paired reads so
# that each plot holds both forward and reverse read information. Also, the
# read count of each sample is recorded. Finally, a plot of read counts is
# created along with a read count table.

require 'biopieces'
require 'csv'
require 'parallel'

cpus    = 20
out_dir = "qc"
samples = CSV.read("samples_collected.txt", col_sep: "\s")

Parallel.each(samples, in_processes: cpus) do |sample|
  $stderr.puts "Start QC: #{sample[0]}"

  BP.new.
  read_fastq(input: sample[1], input2: sample[2], encoding: :base_33).
  merge_pair_seq.
  plot_scores(terminal: :png, output: "#{sample[0]}_scores.png", force: true).
  plot_residue_distribution(terminal: :png, output: "#{sample[0]}_nucdist.png", force: true).
  split_pair_seq.
  count.
  add_key(key: :SAMPLE, value: sample[0]).
  grab(exact: true, keys: :RECORD_TYPE, select: 'count').
  write_table(header: true, output: "#{sample[0]}_count.tab", force: true).
  run(progress: false, output_dir: out_dir, report: "#{sample[0]}.html")

  $stderr.puts "Done QC: #{sample[0]}"
end

$stderr.puts "Start collecting QC"

BP.new.
read_table(input: "#{out_dir}/*_count.tab", delimiter: "\t").
sort(key: :COUNT, reverse: true).
plot_histogram(key: :SAMPLE, value: :COUNT, output: "count.png", terminal: :png, force: true).
write_table(header: true, pretty: true, commify: true, output: "count.tab", force: true, skip: [:RECORD_TYPE]).
run(progress: true, output_dir: out_dir, report: "00_qc_report.html")

$stderr.puts "Done collecting QC"
